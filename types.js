/**
 * Autogenerates typedefs from the api-def. Bundles together any user defined types
 */
const fs = require('fs');
const dedent = require('dedent');

//#region defaults
const defaults = dedent`
  scalar DateTime

  type Query
  type Mutation
  type Subscription {
    test: String
  }

  input DateTimeFilter {
    after: String
    before: String
    notEqualTo: String
    between: [String]
    notBetween: [String]
    in: [String]
    notIn: [String]
    regexp: [String]
    notRegexp: [String]
    exactly: String
  }

  input IntFilter {
    greaterThan: Int
    greaterThanOrEqualTo: Int
    lessThan: Int
    lessThanOrEqualTo: Int
    equalTo: Int
    notEqualTo: Int
    between: [Int]
    notBetween: [Int]
    in: [Int]
    notIn: [Int]
    exactly: Int
  }

  input FloatFilter {
    greaterThan: Float
    greaterThanOrEqualTo: Float
    lessThan: Float
    lessThanOrEqualTo: Float
    equalTo: Float
    notEqualTo: Float
    between: [Float]
    notBetween: [Float]
    in: [Float]
    notIn: [Float]
    exactly: Float
  }

  input BooleanFilter {
    not: Boolean
    exactly: Boolean
  }

  input StringFilter {
    equalTo: String
    notEqualTo: String
    in: [String]
    notIn: [String]
    like: String
    notLike: String
    regexp: String
    notRegexp: String
    exactly: String
  }
`;

//TODO: Make some changes to the defaults
const defaultRead = {
  public: true
}

const defaultUpdate = {
  public: true
}

const defaultCreate = {
  included: true
}

const defaultType = 'String';

//#endregion defaults

/**The default path of the root directory of the graphql api */
const DEFAULT_PATH = '../../graphql';

/**
 * Bundles together default types, autogenerated types, and user-defined types
 * @param {Object} config The config object passed in to the constructor
 * @param {Object} api The api object generated from parsing the .jaml file
 */
const getTypes = (config, api) => {
  //TODO: Add some way to disable this warning.
  if(!config.root_dir) console.warn("No path set in config object. Using default path of /graphql");
  return `
${defaults}
${getAutoGeneratedTypes(config, api)}
${getUserDefinedTypes(config ? config.root_dir : DEFAULT_PATH)}
  `
}

/**
 * Iterates over given folder and builds up user defined types
 * @param {String} path 
 */
const getUserDefinedTypes = (dir) => {
  let res = '';

  fs.readdirSync(dir)
  .filter(file => {
    return fs.statSync(`${dir}/${file}`).isDirectory();
  }).forEach(model => {
    fs.readdirSync(`${dir}/${model}`)
      .filter(file => {
        return (
          file.indexOf('.') !== 0 &&
          (
            file.endsWith('.gql') ||
            file.endsWith('.graphql')
          )
        )
      })
      .forEach(file => {
        let def = fs.readFileSync(`${dir}/${model}/${file}`, 'utf8');
        def = sanitize(def);
        res += def;
      });
  });

  return res;
}

/**
 * Iterates over the api definition object and generates types accordingly
 * @param {Object} api The api object generated from parsing the .jaml file
 */
const getAutoGeneratedTypes = (config, api) => {
  //TODO: Add custom exceptions for improper formatting in the api
  if(!api.models) throw new Error("No models were provided in the api definition");
  
  let res = '';

  Object.values(api.models).forEach(model => {
    let readFields = [];
    let createFields = [];
    let updateFields = [];
    let filterFields = [];
    let enums = [];

    if(model.enums && (typeof model.enums == 'object')){
      enums = Object.values(model.enums);
    }

    if(!model.fields || model.fields.length == 0) return console.warn(`No fields were included for the model ${model.name}`)

    Object.values(model.fields).forEach(field => {
      if(!field.name) throw new Error(`No name provided for field`);

      const readRights = field.read || config.defaults.readRights || defaultRead;
      if(isVisible(readRights)) {
        readFields.push({
          name: field.name,
          type: getType(field),
          required: readRights.required
        });
      }

      const createRights = field.create || config.defaults.createRights || defaultCreate;
      if(isVisible(createRights)) {
        createFields.push({
          name: field.name,
          type: getType(field, 'Create'),
          required: createRights.required
        })  
      }

      const updateRights = field.update || config.defaults.updateRights || defaultUpdate;
      if(isVisible(createRights)) {
        updateFields.push({
          name: field.name,
          type: getType(field, 'Update'),
          required: updateRights.required
        })
      }

      if(field.filterable) {
        filterFields.push({
          name: field.name,
          type: getFilter(field),
          required: updateRights.required
        })
      }
    });

    const modelType = `
    type ${model.name} {
      ${readFields.map(field => `${field.name}: ${field.type}${field.required?'!':''}`).join('\n      ')}
    }
    `;

    const modelCreate = `
    input ${model.name}Create {
      ${createFields.map(field => `${field.name}: ${field.type}${field.required?'!':''}`).join('\n      ')}
    }
    `;
    
    const modelUpdate = `
    input ${model.name}Update {
      ${updateFields.map(field => `${field.name}: ${field.type}${field.required?'!':''}`).join('\n      ')}
    }
    `;

    const modelFilter = `
    input ${model.name}Filter {
      ${filterFields.map(field => `${field.name}: ${field.type}${field.required?'!':''}`).join('\n      ')}
    }
    `

    const query = `
    extend type Query {
      ${model.name.toLowerCase()}(id: Int!): ${model.name}
      ${model.plural.toLowerCase()}(filter: ${model.name}Filter, limit: Int, page: Int): [${model.name}]
    }
    `;

    const mutation = `
    extend type Mutation {
      create${model.name}(input: ${model.name}Create): ${model.name}
      update${model.name}(input: ${model.name}Update, id: Int!): ${model.name}
      delete${model.name}(id: Int!): Boolean
    }
    `

    let enumString = ``;

    enums.forEach(e => {
    enumString += `
    enum ${e.name} {
      ${e.values.join('\n      ')}
    }

    input ${e.name}Filter {
      greaterThan: ${e.name}
      greaterThanOrEqualTo: ${e.name}
      lessThan: ${e.name}
      lessThanOrEqualTo: ${e.name}
      equalTo: ${e.name}
      notEqualTo: ${e.name}
      between: [${e.name}]
      notBetween: [${e.name}]
      in: [${e.name}]
      notIn: [${e.name}]
      exactly: ${e.name}
    }
    `
    })

    res += `
    ${query}
    ${mutation}
    ${modelType}
    ${modelCreate}
    ${modelUpdate}
    ${modelFilter}
    ${enumString}
    `;
  })  
  return dedent(res);
}

const getType = (field, suffix = '') => {
  const type = field.type || config.defaults.type || defaultType;
  if(field.relation) return `${type}${suffix}`;
  return type;
}

const getFilter = (field) => {
  let type = field.type || config.defaults.type || defaultType;
  // if(type.endsWith('Enum')) type = 'Int';
  return `${type}Filter`;
}

/**
 * Takes text input (i.e. read in from a gql/graphql file) and cleans it of any
 * potentially harmful input.
 * @param {String} text 
 */
const sanitize = (text) => {
  //TODO: Implement this function. Not really sure if there's any potentially harmful input, just
  //thought it best to play it safe in case I need it someday.
  return text;
}

const isVisible = (field) => {
  return (
    field.public ||
    field.private ||
    field.protected ||
    field.internal ||
    field.included ||
    field.required
  );
}

module.exports.getTypes = getTypes;